if (jsonMatch) {
                    cleanText = jsonMatch[1];
                }
                // 백슬래시 이스케이프 제거 (마크다운 특수문자용)
                cleanText = cleanText.replace(/\\([\[\]*])/g, '$1');
                
                return JSON.parse(cleanText);
            } catch (e) {
                console.error(`JSON 파싱 오류 (${path}):`, e);
                // 파싱 실패 시 원본 텍스트로 재시도 (혹시 마크다운 없이 순수 JSON일 경우)
                try {
                    return JSON.parse(text);
                } catch (retryError) {
                    throw new Error(`JSON 파싱 실패: ${path}`);
                }
            }
        }

        // ==== UI 렌더링 함수들 ====
        function renderLearningNotes() {
            if (!VEX_NOTES_DATA || VEX_NOTES_DATA.length === 0) {
                 learningNotes.innerHTML = '<p class="text-gray-500">로딩된 학습 노트가 없습니다.</p>';
                 return;
            }
            learningNotes.innerHTML = VEX_NOTES_DATA.map(note => `
                <div class="border-b pb-3 mb-3">
                    <h4 class="font-bold text-gray-800 text-base mb-1">${note.title} <span class="text-xs font-normal text-indigo-500">[${note.category}]</span></h4>
                    <code class="bg-gray-200 text-gray-800 p-1 rounded block mb-1 overflow-x-auto select-all">${note.code}</code>
                    <p class="text-gray-600">${note.desc}</p>
                </div>
            `).join('');
        }

        function loadAllFunctions() {
            if (!VEX_FUNCTIONS || VEX_FUNCTIONS.length === 0) {
                functionList.innerHTML = '<p class="text-gray-500">로딩된 함수가 없습니다.</p>';
                return;
            }
            const allSearchableItems = [
                ...VEX_FUNCTIONS, 
                ...VEX_KEYWORDS.map(k => ({ name: k, desc: "VEX 키워드", syntax: k })),
                ...VEX_ATTRIBUTES.map(a => ({ name: a, desc: "VEX 어트리뷰트", syntax: a }))
            ];

            functionList.innerHTML = allSearchableItems.map(f => `
                <div class="p-3 bg-gray-50 rounded-lg border hover:bg-gray-100 transition-colors">
                    <code class="font-bold text-lg text-blue-700 select-all">${f.name}</code>
                    <p class="text-gray-600 my-1">${f.desc}</p>
                    <code class="text-sm text-gray-500 block overflow-x-auto">${f.syntax || f.name}</code>
                </div>
            `).join('');
        }

        function searchFunctions() {
            const query = functionSearchInput.value.toLowerCase();
            const allSearchableItems = [
                ...VEX_FUNCTIONS, 
                ...VEX_KEYWORDS.map(k => ({ name: k, desc: "VEX 키워드", syntax: k })),
                ...VEX_ATTRIBUTES.map(a => ({ name: a, desc: "VEX 어트리뷰트", syntax: a }))
            ];

            const filteredItems = allSearchableItems.filter(item => 
                item.name.toLowerCase().includes(query) || 
                item.desc.toLowerCase().includes(query) ||
                (item.syntax && item.syntax.toLowerCase().includes(query))
            ).slice(0, 100);

            functionList.innerHTML = filteredItems.map(f => `
                <div class="p-3 bg-gray-50 rounded-lg border hover:bg-gray-100 transition-colors">
                    <code class="font-bold text-lg text-blue-700 select-all">${f.name}</code>
                    <p class="text-gray-600 my-1">${f.desc}</p>
                    <code class="text-sm text-gray-500 block overflow-x-auto">${f.syntax || f.name}</code>
                </div>
            `).join('');

            if (filteredItems.length === 0) {
                functionList.innerHTML = `<p class="text-gray-500 p-4">검색 결과가 없습니다.</p>`;
            }
        }

        // ==== 구문 강조 및 검사 함수들 ====
        function highlightCode(code) {
            let highlightedCode = code;

            if (VEX_FUNCTIONS.length === 0) return highlightedCode;

            // 주석
            highlightedCode = highlightedCode.replace(/(\/\/.*)/g, '<span class="comment">$1</span>');
            // 문자열
            highlightedCode = highlightedCode.replace(/(".*?")/g, '<span class="string">$1</span>');

            const allVexWords = [
                ...VEX_FUNCTIONS.map(f => f.name), 
                ...VEX_KEYWORDS, 
                ...VEX_ATTRIBUTES
            ].sort((a, b) => b.length - a.length);

            allVexWords.forEach(word => {
                let tagClass = 'keyword';
                if (VEX_FUNCTIONS.map(f => f.name).includes(word)) { tagClass = 'function'; }
                else if (VEX_ATTRIBUTES.includes(word)) { tagClass = 'attribute'; }
                else if (['int', 'float', 'vector', 'string', 'void'].includes(word)) { tagClass = 'type'; }

                // HTML 태그 내부가 아닌 텍스트만 치환하기 위한 정규식
                const regex = new RegExp(`(?<!<span[^>]*>)\\b(${word.replace(/[@$]/g, '\\$&')})\\b`, 'g'); 
                highlightedCode = highlightedCode.replace(regex, `<span class="${tagClass}">$1</span>`);
            });
            
            // HTML 엔티티 변환 (보안 및 표시용)
            highlightedCode = highlightedCode.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            
            return highlightedCode;
        }

        function simpleSyntaxCheck(code) {
            if (VEX_FUNCTIONS.length === 0) return;
            
            const errors = [];
            const lines = code.split('\n').filter(line => line.trim() !== '' && !line.trim().startsWith('//'));
            const structuralLineRegex = /^\s*(if|else|for|while|#include|int|float|vector|string|void)/; 

            lines.forEach((line, index) => {
                const trimmed = line.trim();
                if (!structuralLineRegex.test(trimmed) && !trimmed.endsWith(';') && !trimmed.endsWith('}') && !trimmed.endsWith('{')) {
                     errors.push(`[라인 ${index + 1}] 세미콜론(;) 누락 가능성.`);
                }
            });

            // 괄호 검사
            let curly = 0, paren = 0;
            for(let char of code) {
                if(char === '{') curly++;
                if(char === '}') curly--;
                if(char === '(') paren++;
                if(char === ')') paren--;
            }

            if (curly !== 0) errors.push(`중괄호 {} 불일치.`);
            if (paren !== 0) errors.push(`소괄호 () 불일치.`);

            // 피드백 출력
            if (errors.length > 0) {
                feedback.className = 'mt-4 p-3 rounded-lg text-sm border border-red-400 bg-red-100 text-red-700';
                feedback.innerHTML = `<strong>오류/경고:</strong><ul>${errors.map(err => `<li>${err}</li>`).join('')}</ul>`;
            } else {
                feedback.className = 'mt-4 p-3 rounded-lg text-sm border border-green-400 bg-green-100 text-green-700';
                feedback.innerHTML = '<strong>구문 검사 완료:</strong> 큰 문제가 발견되지 않았습니다.';
            }
        }

        function checkSyntax() {
            const code = input.value;
            highlight.innerHTML = highlightCode(code);
            simpleSyntaxCheck(code);
        }

        // ==== AI 설명 요청 (더미/API 연동) ====
        async function explainVEXCode() {
            const code = input.value.trim();
            const output = document.getElementById('explanationOutput');
            
            if (!code) {
                output.innerHTML = '<p class="text-red-500">코드를 입력해주세요.</p>';
                return;
            }

            output.innerHTML = '<p class="text-indigo-600">AI 분석 중...</p>';
            
            // 실제 API 호출 로직은 여기에 위치합니다. 
            // 현재는 데모용으로 간단한 응답을 표시합니다.
            // 실제 환경에서는 API 키와 함께 fetch 요청을 보내야 합니다.
            
            try {
                // 예시: API 호출 시뮬레이션
                await new Promise(r => setTimeout(r, 1000));
                
                // 실제 구현 시: const response = await fetch(...);
                // 지금은 오류 메시지가 아닌 안내 메시지 출력
                output.innerHTML = `
                    <p class="text-gray-800">
                        <strong>[AI 분석 데모]</strong><br>
                        현재 환경에서는 외부 API 호출이 제한될 수 있습니다.<br>
                        입력하신 코드(<code>${code.substring(0, 20)}...</code>)는 
                        VEX 문법에 따라 어트리뷰트를 조작하는 로직으로 보입니다.
                    </p>`;
                output.className = 'mt-2 p-4 rounded-lg text-sm bg-white border border-gray-300';
                
            } catch (error) {
                output.innerHTML = `<p class="text-red-500">오류 발생: ${error.message}</p>`;
            }
        }

        // ==== 초기화 ====
        async function initializeApp() {
            try {
                // 데이터 로드
                const funcData = await loadVexData('vex_functions.txt');
                VEX_KEYWORDS = funcData.keywords || [];
                VEX_ATTRIBUTES = funcData.attributes || [];
                VEX_FUNCTIONS = funcData.functions || [];

                const noteData = await loadVexData('vex_learning_notes.txt');
                VEX_NOTES_DATA = Array.isArray(noteData) ? noteData : [];

                // UI 초기화
                input.placeholder = "// VEX 코드를 입력하세요...";
                input.value = "// 예시 코드\n@N = {0,1,0};\nv@v = @N * 2.0;";
                
                feedback.querySelector('p').textContent = "코드를 입력하면 검사를 시작합니다.";
                functionSearchInput.placeholder = "함수 검색...";
                functionSearchInput.disabled = false;
                explainButton.disabled = false;

                loadAllFunctions();
                renderLearningNotes();
                checkSyntax();

            } catch (error) {
                console.error("Init Error:", error);
                feedback.innerHTML = `<strong class="text-red-600">초기화 실패:</strong> ${error.message}`;
            }
        }

        // 스크롤 동기화
        input.addEventListener('scroll', () => {
            highlight.scrollTop = input.scrollTop;
            highlight.scrollLeft = input.scrollLeft;
        });

        // 탭 키 처리
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = input.selectionStart;
                const end = input.selectionEnd;
                input.value = input.value.substring(0, start) + '    ' + input.value.substring(end);
                input.selectionStart = input.selectionEnd = start + 4;
                checkSyntax();
            }
        });

        // 시작
        window.onload = initializeApp;

    </script>
</body>
</html>
