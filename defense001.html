<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í™”í•™ ì›ì†Œ íƒ€ì›Œ ë””íœìŠ¤</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        #game-container {
            display: flex;
            flex-direction: column;
            background-color: #2d3748; /* Slightly lighter dark */
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            padding: 1.5rem;
            max-width: 90vw; /* Responsive width */
            max-height: 90vh; /* Responsive height */
            box-sizing: border-box;
        }
        canvas {
            background-color: #4a5568; /* Game map background */
            border-radius: 0.75rem;
            border: 2px solid #a0aec0;
            display: block;
            touch-action: none; /* Disable default touch actions */
        }
        .info-panel, .tower-selection {
            background-color: #2d3748;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1rem;
            color: #e2e8f0;
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 0.5rem; /* Space between items */
        }
        .tower-button {
            background-color: #4299e1; /* Blue */
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .tower-button:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
        }
        .tower-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .tower-button.selected {
            background-color: #d69e2e; /* Yellow for selected */
            border: 2px solid #ecc94b;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
            display: none; /* Hidden by default */
        }
        .message-box button {
            background-color: #4299e1;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            cursor: pointer;
            border: none;
            font-weight: bold;
        }

        /* Tower Details Panel Specific Styles */
        #tower-details-panel {
            position: absolute;
            background-color: #3d4858;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: left;
            width: 200px; /* Fixed width for the panel */
            z-index: 999; /* Below message box, above game elements */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            display: none; /* Hidden by default */
        }
        #tower-details-panel h3 {
            border-bottom: 1px solid #606c80;
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
        }
        #tower-details-panel p {
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div id="game-container" class="flex flex-col items-center">
        <div class="info-panel w-full mb-4">
            <div class="flex items-center gap-2">
                <span class="text-xl">ğŸ’°</span>
                <span id="money" class="text-lg font-bold">100</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-xl">â¤ï¸</span>
                <span id="health" class="text-lg font-bold">10</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-xl">ğŸŒŠ</span>
                <span id="wave" class="text-lg font-bold">0</span>
            </div>
            <button id="start-wave-button" class="tower-button bg-green-500 hover:bg-green-600">
                ë‹¤ìŒ ì›¨ì´ë¸Œ ì‹œì‘
            </button>
            <button id="restart-game-button" class="tower-button bg-red-500 hover:bg-red-600">
                ê²Œì„ ë‹¤ì‹œ ì‹œì‘
            </button>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="tower-selection w-full mt-4">
            <button class="tower-button" data-tower-type="Hydrogen">
                <span class="text-2xl">H</span> ìˆ˜ì†Œ ($50)
            </button>
            <button class="tower-button" data-tower-type="Oxygen">
                <span class="text-2xl">O</span> ì‚°ì†Œ ($100)
            </button>
            <button class="tower-button" data-tower-type="Carbon">
                <span class="text-2xl">C</span> íƒ„ì†Œ ($150)
            </button>
        </div>
    </div>

    <!-- Tower Details Panel -->
    <div id="tower-details-panel">
        <h3 id="detail-tower-type"></h3>
        <p>ë ˆë²¨: <span id="detail-tower-level"></span> / 5</p>
        <p>ê³µê²©ë ¥: <span id="detail-tower-damage"></span></p>
        <p>ì‚¬ê±°ë¦¬: <span id="detail-tower-range"></span></p>
        <p>ê³µê²© ì†ë„: <span id="detail-tower-fire-rate"></span></p>
        <button id="upgrade-tower-button" class="tower-button bg-purple-600 hover:bg-purple-700 mt-3 w-full">
            ì—…ê·¸ë ˆì´ë“œ (<span id="detail-upgrade-cost"></span>ğŸ’°)
        </button>
    </div>

    <div id="message-box" class="message-box">
        <h2 id="message-title" class="text-2xl font-bold mb-4"></h2>
        <p id="message-text" class="text-lg mb-6"></p>
        <button id="message-ok-button">í™•ì¸</button>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game dimensions and grid
        const GRID_SIZE = 30; // Size of each grid cell in pixels
        const MAP_COLS = 20;
        const MAP_ROWS = 15;
        canvas.width = MAP_COLS * GRID_SIZE;
        canvas.height = MAP_ROWS * GRID_SIZE;

        // Game state
        let money = 300;
        let health = 10;
        let wave = 0;
        let towers = [];
        let enemies = [];
        let path = []; // Current calculated path for enemies
        let selectedTowerType = null; // For new tower placement
        let selectedTower = null; // For existing tower selection/upgrade
        let gameRunning = false;
        let waveInProgress = false;
        let bossSpawnedThisWave = false; // Track if boss has spawned for current wave

        // HTML elements
        const moneyDisplay = document.getElementById('money');
        const healthDisplay = document.getElementById('health');
        const waveDisplay = document.getElementById('wave');
        const startWaveButton = document.getElementById('start-wave-button');
        const restartGameButton = document.getElementById('restart-game-button');
        const towerButtons = document.querySelectorAll('.tower-button');
        const messageBox = document.getElementById('message-box');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const messageOkButton = document.getElementById('message-ok-button');

        // New HTML elements for tower details panel
        const towerDetailsPanel = document.getElementById('tower-details-panel');
        const detailTowerType = document.getElementById('detail-tower-type');
        const detailTowerLevel = document.getElementById('detail-tower-level');
        const detailTowerDamage = document.getElementById('detail-tower-damage');
        const detailTowerRange = document.getElementById('detail-tower-range');
        const detailTowerFireRate = document.getElementById('detail-tower-fire-rate');
        const upgradeTowerButton = document.getElementById('upgrade-tower-button');
        const detailUpgradeCost = document.getElementById('detail-upgrade-cost');


        // Game map (0: empty, 1: path, 2: tower)
        // This map will be dynamic based on tower placement
        let gameMap = Array(MAP_ROWS).fill(0).map(() => Array(MAP_COLS).fill(0));

        // Start and end points for enemies (grid coordinates)
        const SPAWN_POINT = { r: 7, c: 0 }; // Row 7, Col 0
        const END_POINT = { r: 7, c: MAP_COLS - 1 }; // Row 7, Last Col

        // --- Utility Functions ---

        // Show a custom message box
        function showMessageBox(title, text, callback = null) {
            messageTitle.textContent = title;
            messageText.textContent = text;
            messageBox.style.display = 'block';
            messageOkButton.onclick = () => {
                messageBox.style.display = 'none';
                if (callback) callback();
            };
        }

        // Update UI displays
        function updateUI() {
            moneyDisplay.textContent = money;
            healthDisplay.textContent = health;
            waveDisplay.textContent = wave;
            startWaveButton.disabled = waveInProgress;
        }

        // Convert pixel coordinates to grid coordinates
        function getGridCoords(pixelX, pixelY) {
            return {
                c: Math.floor(pixelX / GRID_SIZE),
                r: Math.floor(pixelY / GRID_SIZE)
            };
        }

        // --- Pathfinding (Breadth-First Search) ---
        // Finds the shortest path from start to end, avoiding obstacles (towers)
        function findPath(map, start, end) {
            const queue = [{ r: start.r, c: start.c, path: [{ r: start.r, c: start.c }] }];
            const visited = new Set();
            visited.add(`${start.r},${start.c}`);

            const directions = [
                { dr: -1, dc: 0 }, // Up
                { dr: 1, dc: 0 },  // Down
                { dr: 0, dc: -1 }, // Left
                { dr: 0, dc: 1 }   // Right
            ];

            while (queue.length > 0) {
                const { r, c, path } = queue.shift();

                if (r === end.r && c === end.c) {
                    return path; // Path found!
                }

                for (const dir of directions) {
                    const nr = r + dir.dr;
                    const nc = c + dir.dc;

                    // Check bounds
                    if (nr >= 0 && nr < MAP_ROWS && nc >= 0 && nc < MAP_COLS) {
                        // Check if not visited and not a tower (obstacle)
                        if (!visited.has(`${nr},${nc}`) && map[nr][nc] !== 2) {
                            visited.add(`${nr},${nc}`);
                            queue.push({ r: nr, c: nc, path: [...path, { r: nr, c: nc }] });
                        }
                    }
                }
            }
            return null; // No path found
        }

        // --- Game Assets (Images) ---
        const gameAssets = {
            images: {
                // Tower images (placeholder URLs, replace with your actual image URLs)
                Hydrogen: { url: 'https://placehold.co/60x60/ADD8E6/000000?text=H_Tower', img: null },
                Oxygen: { url: 'https://placehold.co/60x60/FF6347/000000?text=O_Tower', img: null },
                Carbon: { url: 'https://placehold.co/60x60/A9A9A9/000000?text=C_Tower', img: null },
                // Enemy images (placeholder URLs, replace with your actual image URLs)
                NitrogenMolecule: { url: 'https://placehold.co/40x40/90EE90/000000?text=N2', img: null },
                OxygenMolecule: { url: 'https://placehold.co/40x40/FFA07A/000000?text=O2', img: null },
                HydrogenMolecule: { url: 'https://placehold.co/40x40/87CEEB/000000?text=H2', img: null },
                // Boss images (placeholder URLs, replace with your actual image URLs)
                FreonGas: { url: 'https://placehold.co/70x70/800080/FFFFFF?text=CFC_Boss', img: null },
                HydrofluoricAcid: { url: 'https://placehold.co/70x70/4682B4/FFFFFF?text=HF_Boss', img: null }
            }
        };

        // --- Preload Images Function ---
        function preloadImages(callback) {
            let loadedCount = 0;
            let totalImages = Object.keys(gameAssets.images).length;

            if (totalImages === 0) { // If no images to load, proceed immediately
                callback();
                return;
            }

            for (const key in gameAssets.images) {
                const asset = gameAssets.images[key];
                asset.img = new Image();
                asset.img.src = asset.url;
                asset.img.onload = () => {
                    loadedCount++;
                    if (loadedCount === totalImages) {
                        callback(); // All images loaded
                    }
                };
                asset.img.onerror = () => {
                    console.error(`ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${asset.url}`);
                    // Fallback: If image fails to load, still increment count to prevent blocking
                    loadedCount++;
                    if (loadedCount === totalImages) {
                        callback();
                    }
                };
            }
        }

        // --- Game Entities ---

        class Tower {
            constructor(r, c, type) {
                this.r = r;
                this.c = c;
                this.x = c * GRID_SIZE + GRID_SIZE / 2;
                this.y = r * GRID_SIZE + GRID_SIZE / 2;
                this.type = type;
                this.level = 1;
                this.color = ''; // Fallback color if image fails
                this.attackRange = 0;
                this.baseAttackDamage = 0; // Store initial damage for calculation
                this.attackDamage = 0; // Current damage
                this.fireRate = 0; // Attacks per second
                this.lastAttackTime = 0;
                this.cost = 0; // Initial placement cost
                this.baseCost = 0; // Store initial cost for upgrade cost calculation
                this.maxLevel = 5;
                this.currentUpgradeCost = 0;

                // Assign image and set dimensions
                this.image = gameAssets.images[type].img;
                this.width = GRID_SIZE * 0.9; // Image width relative to grid size
                this.height = GRID_SIZE * 0.9; // Image height relative to grid size

                switch (type) {
                    case 'Hydrogen':
                        this.color = '#ADD8E6'; // Light Blue
                        this.attackRange = GRID_SIZE * 2.5;
                        this.baseAttackDamage = 10;
                        this.fireRate = 2;
                        this.baseCost = 50;
                        break;
                    case 'Oxygen':
                        this.color = '#FF6347'; // Tomato (Reddish)
                        this.attackRange = GRID_SIZE * 3;
                        this.baseAttackDamage = 30;
                        this.fireRate = 1;
                        this.baseCost = 100;
                        break;
                    case 'Carbon':
                        this.color = '#A9A9A9'; // Dark Gray
                        this.attackRange = GRID_SIZE * 2;
                        this.baseAttackDamage = 60;
                        this.fireRate = 0.5;
                        this.baseCost = 150;
                        break;
                }
                this.attackDamage = this.baseAttackDamage; // Initialize current damage
                this.cost = this.baseCost; // Initialize placement cost
                this.currentUpgradeCost = this.calculateUpgradeCost(); // Initialize upgrade cost
            }

            // Calculate the cost for the next upgrade
            calculateUpgradeCost() {
                if (this.level >= this.maxLevel) return Infinity; // Max level reached, no more upgrades
                // Cost increases by 75% of base cost per level
                return Math.floor(this.baseCost * (1 + this.level * 0.75));
            }

            // Upgrade the tower
            upgrade() {
                if (this.level < this.maxLevel) {
                    this.level++;
                    this.attackDamage = this.baseAttackDamage * (2 ** (this.level - 1)); // Damage x2 per level
                    this.currentUpgradeCost = this.calculateUpgradeCost(); // Recalculate for next level
                    return true;
                }
                return false;
            }

            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    // Draw image if loaded
                    ctx.drawImage(this.image, this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                } else {
                    // Fallback: Draw circle and symbol if image not loaded or failed
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, GRID_SIZE / 2 * 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = 'black';
                    ctx.font = `${GRID_SIZE * 0.5}px Inter`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.type[0], this.x, this.y);
                }

                // Draw range for selected tower (for visual feedback)
                if (selectedTower === this) { // Only show range for the currently selected tower
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.attackRange, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            update(deltaTime) {
                const now = Date.now();
                if (now - this.lastAttackTime >= (1000 / this.fireRate)) {
                    // Find target
                    let target = null;
                    // Prioritize bosses if present
                    for (const enemy of enemies) {
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist <= this.attackRange) {
                            if (enemy instanceof BossEnemy) { // Target boss first
                                target = enemy;
                                break;
                            } else if (!target) { // Otherwise, target first regular enemy
                                target = enemy;
                            }
                        }
                    }

                    if (target) {
                        target.takeDamage(this.attackDamage);
                        this.lastAttackTime = now;

                        // Draw projectile (simple line for now)
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(target.x, target.y);
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }
        }

        class Enemy {
            constructor(type, path) {
                this.type = type;
                this.health = 0;
                this.maxHealth = 0;
                this.speed = 0; // Pixels per second
                this.color = ''; // Fallback color if image fails
                this.path = path;
                this.pathIndex = 0;
                this.x = this.path[0].c * GRID_SIZE + GRID_SIZE / 2;
                this.y = this.path[0].r * GRID_SIZE + GRID_SIZE / 2;
                this.radius = GRID_SIZE * 0.3; // Fallback radius
                this.isDead = false;
                this.moneyReward = 10;

                // Assign image and set dimensions
                this.image = gameAssets.images[type].img;
                this.width = GRID_SIZE * 0.7; // Image width relative to grid size
                this.height = GRID_SIZE * 0.7; // Image height relative to grid size

                switch (type) {
                    case 'NitrogenMolecule': // N2 - Most common, basic
                        this.maxHealth = 60;
                        this.speed = 70;
                        this.color = '#90EE90'; // Light Green
                        break;
                    case 'OxygenMolecule': // O2 - More common, slightly stronger
                        this.maxHealth = 90;
                        this.speed = 60;
                        this.color = '#FFA07A'; // Light Salmon
                        break;
                    case 'HydrogenMolecule': // H2 - Less common, very fast, low health
                        this.maxHealth = 40;
                        this.speed = 100;
                        this.color = '#87CEEB'; // Sky Blue
                        break;
                }
                this.health = this.maxHealth;
            }

            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    // Draw image if loaded
                    ctx.drawImage(this.image, this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                } else {
                    // Fallback: Draw circle if image not loaded or failed
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Health bar
                const barWidth = this.width * 0.8; // Health bar width relative to image width
                const barHeight = 5;
                const healthRatio = this.health / this.maxHealth;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - barHeight - 2, barWidth, barHeight);
                ctx.fillStyle = 'lime';
                ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - barHeight - 2, barWidth * healthRatio, barHeight);
            }

            update(deltaTime) {
                if (this.isDead) return;

                if (this.pathIndex < this.path.length - 1) {
                    const nextWaypoint = {
                        x: this.path[this.pathIndex + 1].c * GRID_SIZE + GRID_SIZE / 2,
                        y: this.path[this.pathIndex + 1].r * GRID_SIZE + GRID_SIZE / 2
                    };

                    const dx = nextWaypoint.x - this.x;
                    const dy = nextWaypoint.y - this.y;
                    const distance = Math.hypot(dx, dy);

                    const moveAmount = this.speed * (deltaTime / 1000);

                    if (distance <= moveAmount) {
                        this.x = nextWaypoint.x;
                        this.y = nextWaypoint.y;
                        this.pathIndex++;
                    } else {
                        this.x += (dx / distance) * moveAmount;
                        this.y += (dy / distance) * moveAmount;
                    }
                } else {
                    // Reached the end
                    this.isDead = true;
                    health--;
                    updateUI();
                    if (health <= 0) {
                        gameOver();
                    }
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.isDead = true;
                    money += this.moneyReward; // Reward for killing enemy
                    updateUI();
                }
            }
        }

        class BossEnemy extends Enemy {
            constructor(type, path) {
                super(type, path); // Call parent constructor
                this.radius = GRID_SIZE * 0.45; // Fallback radius
                this.moneyReward = 100; // More money for boss

                // Assign image and set dimensions for boss
                this.image = gameAssets.images[type].img;
                this.width = GRID_SIZE * 1.2; // Larger image width for boss
                this.height = GRID_SIZE * 1.2; // Larger image height for boss

                switch (type) {
                    case 'FreonGas': // CFC - High health, moderate speed
                        this.maxHealth = 500;
                        this.speed = 40;
                        this.color = '#800080'; // Purple
                        break;
                    case 'HydrofluoricAcid': // HF - Very high health, slow
                        this.maxHealth = 800;
                        this.speed = 30;
                        this.color = '#4682B4'; // Steel Blue
                        break;
                }
                this.health = this.maxHealth;
            }

            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    // Draw image if loaded
                    ctx.drawImage(this.image, this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                } else {
                    // Fallback: Draw distinct shape for boss if image not loaded or failed
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.strokeStyle = '#FFD700'; // Gold border for boss
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    ctx.fillStyle = 'white';
                    ctx.font = `${GRID_SIZE * 0.4}px Inter`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.type === 'FreonGas' ? 'CFC' : 'HF', this.x, this.y);
                }

                // Health bar (same as regular enemy)
                const barWidth = this.width * 0.8; // Health bar width relative to image width
                const barHeight = 5;
                const healthRatio = this.health / this.maxHealth;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - barHeight - 2, barWidth, barHeight);
                ctx.fillStyle = 'lime';
                ctx.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - barHeight - 2, barWidth * healthRatio, barHeight);
            }
        }


        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(currentTime) {
            if (!gameRunning) return;

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].update(deltaTime);
                if (enemies[i].isDead) {
                    enemies.splice(i, 1);
                }
            }

            // Update towers
            for (const tower of towers) {
                tower.update(deltaTime);
            }

            // Check wave completion
            if (waveInProgress && enemies.length === 0) {
                waveInProgress = false;
                bossSpawnedThisWave = false; // Reset for next wave
                startWaveButton.disabled = false;
                showMessageBox("ì›¨ì´ë¸Œ ì™„ë£Œ!", `ì›¨ì´ë¸Œ ${wave}ë¥¼ ì„±ê³µì ìœ¼ë¡œ ë§‰ì•˜ìŠµë‹ˆë‹¤! ë‹¤ìŒ ì›¨ì´ë¸Œë¥¼ ì‹œì‘í•˜ì„¸ìš”.`, () => {
                    // Optional: give bonus money, health, etc.
                });
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            // Draw grid lines
            ctx.strokeStyle = '#606c80'; // Lighter gray for grid
            ctx.lineWidth = 0.5;
            for (let r = 0; r < MAP_ROWS; r++) {
                for (let c = 0; c < MAP_COLS; c++) {
                    ctx.strokeRect(c * GRID_SIZE, r * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                }
            }

            // Draw path (if exists)
            if (path && path.length > 0) {
                ctx.beginPath();
                ctx.moveTo(path[0].c * GRID_SIZE + GRID_SIZE / 2, path[0].r * GRID_SIZE + GRID_SIZE / 2);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].c * GRID_SIZE + GRID_SIZE / 2, path[i].r * GRID_SIZE + GRID_SIZE / 2);
                }
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)'; // Yellow transparent path
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            // Draw towers
            for (const tower of towers) {
                tower.draw();
            }

            // Draw enemies
            for (const enemy of enemies) {
                enemy.draw();
            }
        }

        // --- Game Initialization & Events ---

        function initGame() {
            updateUI();
            // Initial path calculation (before any towers are placed)
            path = findPath(gameMap, SPAWN_POINT, END_POINT);
            if (!path) {
                showMessageBox("ì˜¤ë¥˜", "ì´ˆê¸° ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë§µ ì„¤ì • ì˜¤ë¥˜.");
                gameRunning = false;
                return;
            }
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameRunning = false;
            waveInProgress = false;
            showMessageBox("ê²Œì„ ì˜¤ë²„!", `ê¸°ì§€ê°€ íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤! ì›¨ì´ë¸Œ ${wave}ê¹Œì§€ ì§„í–‰í–ˆìŠµë‹ˆë‹¤.`, () => {
                // Reset game or go to main menu
                location.reload(); // Simple reload for now
            });
        }

        // Function to update the tower details panel
        function updateTowerDetailsPanel() {
            if (selectedTower) {
                detailTowerType.textContent = selectedTower.type;
                detailTowerLevel.textContent = selectedTower.level;
                detailTowerDamage.textContent = selectedTower.attackDamage;
                detailTowerRange.textContent = (selectedTower.attackRange / GRID_SIZE).toFixed(1) + 'ì¹¸'; // Convert pixels to grid units
                detailTowerFireRate.textContent = selectedTower.fireRate + 'íšŒ/ì´ˆ';

                if (selectedTower.level < selectedTower.maxLevel) {
                    detailUpgradeCost.textContent = selectedTower.currentUpgradeCost;
                    upgradeTowerButton.disabled = false;
                    upgradeTowerButton.textContent = `ì—…ê·¸ë ˆì´ë“œ (${selectedTower.currentUpgradeCost}ğŸ’°)`;
                    if (money < selectedTower.currentUpgradeCost) {
                        upgradeTowerButton.classList.add('opacity-50', 'cursor-not-allowed');
                    } else {
                        upgradeTowerButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                } else {
                    upgradeTowerButton.textContent = 'ìµœëŒ€ ë ˆë²¨';
                    upgradeTowerButton.disabled = true;
                    upgradeTowerButton.classList.add('opacity-50', 'cursor-not-allowed');
                }
                towerDetailsPanel.style.display = 'block';
                // Position the panel near the tower
                // Adjust position to prevent going off-screen on the right
                const panelX = selectedTower.x + GRID_SIZE;
                const panelY = selectedTower.y;
                const panelWidth = towerDetailsPanel.offsetWidth;
                const panelHeight = towerDetailsPanel.offsetHeight;

                if (panelX + panelWidth > canvas.width) {
                    towerDetailsPanel.style.left = `${selectedTower.x - GRID_SIZE - panelWidth}px`;
                } else {
                    towerDetailsPanel.style.left = `${panelX}px`;
                }
                if (panelY + panelHeight > canvas.height) {
                    towerDetailsPanel.style.top = `${canvas.height - panelHeight - 10}px`; // 10px padding from bottom
                } else {
                    towerDetailsPanel.style.top = `${panelY}px`;
                }

            } else {
                towerDetailsPanel.style.display = 'none';
            }
        }


        // Tower placement and selection logic
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const { r, c } = getGridCoords(clickX, clickY);

            // 1. Check if an existing tower was clicked
            let clickedExistingTower = false;
            for (const tower of towers) {
                if (tower.r === r && tower.c === c) {
                    selectedTower = tower;
                    updateTowerDetailsPanel();
                    clickedExistingTower = true;
                    break;
                }
            }

            if (clickedExistingTower) {
                // If an existing tower was clicked, clear any new tower type selection
                selectedTowerType = null;
                towerButtons.forEach(btn => btn.classList.remove('selected'));
                return; // Stop here, no new tower placement
            }

            // 2. If no existing tower was clicked, proceed with new tower placement logic
            if (!selectedTowerType || waveInProgress) {
                if (waveInProgress) showMessageBox("ê²½ê³ ", "ì›¨ì´ë¸Œê°€ ì§„í–‰ ì¤‘ì¼ ë•ŒëŠ” íƒ€ì›Œë¥¼ ë°°ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                // If no tower type is selected and no existing tower was clicked, hide the panel
                selectedTower = null;
                updateTowerDetailsPanel();
                return;
            }

            // Prevent placing on spawn or end points
            if ((r === SPAWN_POINT.r && c === SPAWN_POINT.c) || (r === END_POINT.r && c === END_POINT.c)) {
                showMessageBox("ê²½ê³ ", "ì‹œì‘ ë˜ëŠ” ì¢…ë£Œ ì§€ì ì—ëŠ” íƒ€ì›Œë¥¼ ë°°ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }

            // Check if cell is already occupied by a tower
            if (gameMap[r][c] === 2) {
                showMessageBox("ê²½ê³ ", "ì´ë¯¸ íƒ€ì›Œê°€ ìˆëŠ” ìœ„ì¹˜ì…ë‹ˆë‹¤.");
                return;
            }

            // Get tower cost (create a temporary instance to get cost)
            const towerCost = new Tower(0, 0, selectedTowerType).cost;
            if (money < towerCost) {
                showMessageBox("ê²½ê³ ", "ìê¸ˆì´ ë¶€ì¡±í•©ë‹ˆë‹¤!");
                return;
            }

            // --- Path validation: Crucial for maze building ---
            // Temporarily place the tower on the map
            gameMap[r][c] = 2;
            const newPath = findPath(gameMap, SPAWN_POINT, END_POINT);

            if (newPath) {
                // Path is still valid, commit placement
                const newTower = new Tower(r, c, selectedTowerType);
                towers.push(newTower);
                money -= towerCost;
                path = newPath; // Update global path
                updateUI();
                // Deselect tower type after placement
                selectedTowerType = null;
                towerButtons.forEach(btn => btn.classList.remove('selected'));
                // Hide tower details panel if it was open
                selectedTower = null;
                updateTowerDetailsPanel();
            } else {
                // No path found, revert placement
                gameMap[r][c] = 0; // Revert to empty
                showMessageBox("ê²½ê³ ", "íƒ€ì›Œë¥¼ ë°°ì¹˜í•˜ë©´ ì ì˜ ê²½ë¡œê°€ ë§‰í™ë‹ˆë‹¤! ë‹¤ë¥¸ ê³³ì— ë°°ì¹˜í•˜ì„¸ìš”.");
            }
        });

        // Tower selection buttons
        towerButtons.forEach(button => {
            button.addEventListener('click', () => {
                const type = button.dataset.towerType;
                if (selectedTowerType === type) {
                    selectedTowerType = null; // Deselect if already selected
                    button.classList.remove('selected');
                } else {
                    selectedTowerType = type;
                    towerButtons.forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                }
                // When a new tower type is selected, clear any existing tower selection
                selectedTower = null;
                updateTowerDetailsPanel(); // Hide the panel
            });
        });

        // Start wave button
        startWaveButton.addEventListener('click', () => {
            if (waveInProgress) return;
            wave++;
            waveInProgress = true;
            bossSpawnedThisWave = false; // Ensure boss flag is reset for new wave
            updateUI();
            // Hide tower details panel when wave starts
            selectedTower = null;
            updateTowerDetailsPanel();
            spawnWave(wave);
        });

        // Restart Game button
        restartGameButton.addEventListener('click', () => {
            // Simply reload the page to restart the entire game
            location.reload();
        });

        // Event listener for upgrade button
        upgradeTowerButton.addEventListener('click', () => {
            if (selectedTower && selectedTower.level < selectedTower.maxLevel) {
                const cost = selectedTower.currentUpgradeCost;
                if (money >= cost) {
                    money -= cost;
                    selectedTower.upgrade();
                    updateUI();
                    updateTowerDetailsPanel(); // Update panel with new stats
                } else {
                    showMessageBox("ìê¸ˆ ë¶€ì¡±", "íƒ€ì›Œë¥¼ ì—…ê·¸ë ˆì´ë“œí•  ìê¸ˆì´ ë¶€ì¡±í•©ë‹ˆë‹¤!");
                }
            } else if (selectedTower && selectedTower.level >= selectedTower.maxLevel) {
                showMessageBox("ìµœëŒ€ ë ˆë²¨", "ì´ íƒ€ì›ŒëŠ” ì´ë¯¸ ìµœëŒ€ ë ˆë²¨ì…ë‹ˆë‹¤.");
            }
        });


        // --- Wave Spawning Logic ---
        function spawnWave(currentWave) {
            let regularEnemyCount = 10 + currentWave * 3; // More regular enemies per wave
            let enemyTypes = [];

            // Add enemy types based on wave progress, simulating atmospheric composition
            // Nitrogen (N2) is always present
            enemyTypes.push({ type: 'NitrogenMolecule', weight: 78 }); // ~78% of atmosphere
            if (currentWave >= 1) {
                enemyTypes.push({ type: 'OxygenMolecule', weight: 21 }); // ~21% of atmosphere
            }
            if (currentWave >= 3) {
                enemyTypes.push({ type: 'HydrogenMolecule', weight: 1 }); // Trace amounts, but distinct gameplay
            }

            let spawnedCount = 0;
            const spawnDelay = 700 - (currentWave * 20); // Faster spawns in later waves, min 200ms
            if (spawnDelay < 200) spawnDelay = 200;

            const spawnInterval = setInterval(() => {
                if (spawnedCount < regularEnemyCount) {
                    // Weighted random selection for enemy types
                    let totalWeight = enemyTypes.reduce((sum, type) => sum + type.weight, 0);
                    let randomNum = Math.random() * totalWeight;
                    let selectedEnemyType = null;
                    for (const type of enemyTypes) {
                        randomNum -= type.weight;
                        if (randomNum <= 0) {
                            selectedEnemyType = type.type;
                            break;
                        }
                    }

                    const newEnemy = new Enemy(selectedEnemyType, path);
                    enemies.push(newEnemy);
                    spawnedCount++;
                } else {
                    clearInterval(spawnInterval);
                    // All regular enemies spawned, now spawn boss if not already
                    if (!bossSpawnedThisWave) {
                        spawnBoss(currentWave);
                        bossSpawnedThisWave = true;
                    }
                }
            }, spawnDelay);
        }

        function spawnBoss(currentWave) {
            let bossType = 'FreonGas';
            if (currentWave % 2 === 0) { // Alternate boss types
                bossType = 'HydrofluoricAcid';
            }

            // Add a slight delay before boss spawns after last regular enemy
            setTimeout(() => {
                const newBoss = new BossEnemy(bossType, path);
                enemies.push(newBoss);
                showMessageBox("ë³´ìŠ¤ ë“±ì¥!", `${newBoss.type} ë³´ìŠ¤ê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!`);
            }, 2000); // 2 seconds after last regular enemy
        }


        // Initialize the game when the window loads
        window.onload = () => {
            showMessageBox("ë¡œë”© ì¤‘...", "ê²Œì„ì— í•„ìš”í•œ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...");
            preloadImages(() => {
                messageBox.style.display = 'none'; // Hide loading message
                initGame();
            });
        };

        // Handle window resize for responsiveness
        window.addEventListener('resize', () => {
            // Recalculate canvas size based on container or fixed ratio
            // For simplicity, we'll keep fixed grid size and map dimensions for now.
            // If you want dynamic resizing, you'd need to adjust GRID_SIZE or MAP_COLS/MAP_ROWS
            // and re-render all elements. For this example, we'll rely on CSS for container scaling.
        });
    </script>
</body>
</html>
