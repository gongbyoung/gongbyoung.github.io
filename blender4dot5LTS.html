<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>블렌더 4.5 LTS Geometry Node 탐색기</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
        }
        #root { display: none; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 antialiased">
    <div id="root"></div>

    <!-- React and ReactDOM CDNs -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script>
        // Use pure JavaScript and React without Babel
        window.onload = function() {
            const { useState, useMemo } = React;
            
            // 데이터: Blender 4.5 LTS Geometry Nodes
            const nodeData = {
                "Group Input": {
                    inputs: [],
                    outputs: [{ type: "Geometry", description: "입력된 지오메트리" }],
                    connectsTo: ["Group Output", "Join Geometry", "Set Position", "Extrude Mesh", "Subdivision Surface"]
                },
                "Group Output": {
                    inputs: [{ type: "Geometry", description: "출력할 최종 지오메트리" }],
                    outputs: [],
                    connectsTo: ["Group Input"]
                },
                "Join Geometry": {
                    inputs: [{ type: "Geometry", description: "합칠 지오메트리들" }],
                    outputs: [{ type: "Geometry", description: "하나로 합쳐진 지오메트리" }],
                    connectsTo: ["Set Position", "Extrude Mesh", "Group Output", "Subdivision Surface"]
                },
                "Set Position": {
                    inputs: [
                        { type: "Geometry", description: "위치를 변경할 지오메트리" },
                        { type: "Vector", description: "새로운 위치" },
                        { type: "Vector", description: "위치 오프셋 값" }
                    ],
                    outputs: [{ type: "Geometry", description: "위치가 변경된 지오메트리" }],
                    connectsTo: ["Join Geometry", "Extrude Mesh", "Group Output", "Subdivision Surface"]
                },
                "Extrude Mesh": {
                    inputs: [
                        { type: "Mesh", description: "압출할 메쉬" },
                        { type: "Vector", description: "압출 방향" },
                        { type: "Float", description: "압출 거리" }
                    ],
                    outputs: [{ type: "Mesh", description: "압출된 메쉬" }],
                    connectsTo: ["Join Geometry", "Group Output", "Set Position", "Subdivision Surface"]
                },
                "Transform": {
                    inputs: [
                        { type: "Geometry", description: "변환할 지오메트리" },
                        { type: "Vector", description: "이동 값" },
                        { type: "Vector", description: "회전 값" },
                        { type: "Vector", description: "스케일 값" }
                    ],
                    outputs: [{ type: "Geometry", description: "변환된 지오메트리" }],
                    connectsTo: ["Join Geometry", "Group Output"]
                },
                "Instance on Points": {
                    inputs: [
                        { type: "Geometry", description: "인스턴스를 배치할 점" },
                        { type: "Geometry", description: "인스턴스 할 지오메트리" },
                        { type: "Vector", description: "회전 값" },
                        { type: "Vector", description: "스케일 값" }
                    ],
                    outputs: [{ type: "Geometry", description: "인스턴스가 배치된 지오메트리" }],
                    connectsTo: ["Join Geometry", "Group Output"]
                },
                "Distribute Points on Faces": {
                    inputs: [
                        { type: "Mesh", description: "점을 생성할 메쉬" },
                        { type: "Float", description: "점 밀도" }
                    ],
                    outputs: [
                        { type: "Points", description: "생성된 점" },
                        { type: "Float", description: "선택 출력" }
                    ],
                    connectsTo: ["Instance on Points", "Set Position"]
                },
                "Curve to Mesh": {
                    inputs: [
                        { type: "Curve", description: "변환할 커브" },
                        { type: "Mesh", description: "프로파일 메쉬" }
                    ],
                    outputs: [{ type: "Mesh", description: "변환된 메쉬" }],
                    connectsTo: ["Extrude Mesh", "Join Geometry"]
                },
                "Resample Curve": {
                    inputs: [
                        { type: "Curve", description: "재샘플링할 커브" },
                        { type: "Float", description: "길이" },
                        { type: "Integer", description: "점 개수" }
                    ],
                    outputs: [{ type: "Curve", description: "재샘플링된 커브" }],
                    connectsTo: ["Curve to Mesh", "Set Position"]
                },
                "Subdivision Surface": {
                    inputs: [
                        { type: "Geometry", description: "세분화할 지오메트리" },
                        { type: "Integer", description: "세분화 레벨" }
                    ],
                    outputs: [{ type: "Geometry", description: "세분화된 지오메트리" }],
                    connectsTo: ["Group Output", "Extrude Mesh", "Set Position", "Join Geometry"]
                },
                "Merge by Distance": {
                    inputs: [
                        { type: "Geometry", description: "병합할 지오메트리" },
                        { type: "Float", description: "병합 거리" }
                    ],
                    outputs: [{ type: "Geometry", description: "버텍스가 병합된 지오메트리" }],
                    connectsTo: ["Group Output", "Subdivision Surface"]
                },
                "Delete Geometry": {
                    inputs: [
                        { type: "Geometry", description: "삭제할 지오메트리" },
                        { type: "Boolean", description: "선택" }
                    ],
                    outputs: [{ type: "Geometry", description: "지오메트리가 삭제된 결과" }],
                    connectsTo: ["Group Output", "Extrude Mesh"]
                }
            };
            
            // Function to format the value type into a color and label
            const formatValueType = (type) => {
                switch (type) {
                    case "Geometry": return { color: "bg-gray-400", label: "지오메트리" };
                    case "Mesh": return { color: "bg-blue-400", label: "메쉬" };
                    case "Vector": return { color: "bg-purple-400", label: "벡터" };
                    case "Float": return { color: "bg-green-400", label: "플로트" };
                    case "Integer": return { color: "bg-red-400", label: "정수" };
                    case "Points": return { color: "bg-yellow-400", label: "점" };
                    case "Curve": return { color: "bg-orange-400", label: "커브" };
                    case "Boolean": return { color: "bg-pink-400", label: "불리언" };
                    default: return { color: "bg-gray-400", label: type };
                }
            };

            // React element creation helper
            const e = React.createElement;

            // Component to display detailed information about a selected node
            const NodeDetail = ({ nodeName, data, onNodeClick }) => {
                const [llmResponse, setLlmResponse] = useState(null);
                const [isLoading, setIsLoading] = useState(false);
                
                // Function to call the Gemini API for a detailed explanation
                const getLlmExplanation = async () => {
                    setIsLoading(true);
                    setLlmResponse(null);
                    
                    try {
                        const prompt = `블렌더 지오메트리 노드인 "${nodeName}"에 대해 상세하게 설명해줘. 이 노드가 어떤 역할을 하고, 어떤 상황에 주로 사용되는지, 그리고 초보자도 이해하기 쉽게 비유를 들어서 설명해줘.`;
                        const apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=';

                        const payload = {
                            contents: [{ parts: [{ text: prompt }] }],
                            tools: [{ "google_search": {} }],
                            systemInstruction: { parts: [{ text: "You are a helpful assistant specialized in explaining Blender Geometry Nodes. Your explanations are clear, concise, and easy for beginners to understand." }] }
                        };

                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        
                        const result = await response.json();
                        const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (text) {
                            setLlmResponse(text);
                        } else {
                            setLlmResponse("정보를 가져오는 데 실패했습니다. 다시 시도해 주세요.");
                        }
                    } catch (error) {
                        console.error('API call failed:', error);
                        setLlmResponse("API 호출 중 오류가 발생했습니다. 잠시 후 다시 시도해 주세요.");
                    } finally {
                        setIsLoading(false);
                    }
                };

                // JSX structure translated to React.createElement calls
                return e("div", { className: "p-6 border-2 border-yellow-500 rounded-lg bg-gray-900" },
                    e("h2", { className: "text-3xl font-bold mb-4 text-yellow-300" }, nodeName),
                    
                    // Input section
                    e("div", { className: "mb-6" },
                        e("h3", { className: "text-xl font-semibold mb-2" }, "입력 값"),
                        data.inputs.length > 0 ? (
                            e("ul", { className: "space-y-2" },
                                data.inputs.map((input, index) => {
                                    const { color, label } = formatValueType(input.type);
                                    return e("li", { key: index, className: "flex items-center space-x-3" },
                                        e("span", { className: `w-3 h-3 rounded-full ${color}` }),
                                        e("span", { className: "text-gray-300 font-medium" }, `${label}:`),
                                        e("span", { className: "text-gray-400" }, input.description)
                                    );
                                })
                            )
                        ) : (
                            e("p", { className: "text-gray-500 italic" }, "이 노드는 입력 값이 없습니다.")
                        )
                    ),
                    
                    // Output section
                    e("div", { className: "mb-6" },
                        e("h3", { className: "text-xl font-semibold mb-2" }, "출력 값"),
                        data.outputs.length > 0 ? (
                            e("ul", { className: "space-y-2" },
                                data.outputs.map((output, index) => {
                                    const { color, label } = formatValueType(output.type);
                                    return e("li", { key: index, className: "flex items-center space-x-3" },
                                        e("span", { className: `w-3 h-3 rounded-full ${color}` }),
                                        e("span", { className: "text-gray-300 font-medium" }, `${label}:`),
                                        e("span", { className: "text-gray-400" }, output.description)
                                    );
                                })
                            )
                        ) : (
                            e("p", { className: "text-gray-500 italic" }, "이 노드는 출력 값이 없습니다.")
                        )
                    ),
                    
                    // Connectable nodes section
                    e("div", { className: "mb-6" },
                        e("h3", { className: "text-xl font-semibold mb-2" }, "연결 가능한 다음 노드"),
                        data.connectsTo.length > 0 ? (
                            e("div", { className: "flex flex-wrap gap-2" },
                                data.connectsTo.map((node, index) => 
                                    e("button", {
                                        key: index,
                                        onClick: () => onNodeClick(node),
                                        className: "px-4 py-2 rounded-lg bg-gray-700 text-yellow-300 font-medium hover:bg-yellow-500 hover:text-gray-900 transition-colors duration-200 shadow-md"
                                    }, node)
                                )
                            )
                        ) : (
                            e("p", { className: "text-gray-500 italic" }, "이 노드는 다음 노드로 연결되지 않습니다.")
                        )
                    ),

                    // Gemini API button and response
                    e("div", { className: "mt-8" },
                        e("button", {
                            onClick: getLlmExplanation,
                            className: "w-full py-3 rounded-lg bg-yellow-500 text-gray-900 font-bold text-lg hover:bg-yellow-400 transition-colors duration-200 shadow-md",
                            disabled: isLoading
                        }, isLoading ? "로딩 중..." : "자세히 보기 ✨"),
                        llmResponse && e("div", {
                            className: "mt-6 p-4 bg-gray-700 rounded-lg whitespace-pre-wrap"
                        },
                            e("h4", { className: "text-lg font-semibold mb-2" }, "자세한 설명:"),
                            e("p", null, llmResponse)
                        )
                    )
                );
            };

            // Main application component
            const App = () => {
                const [searchTerm, setSearchTerm] = useState('');
                const [selectedNode, setSelectedNode] = useState(null);
            
                // Memoized filtered list of nodes for performance
                const filteredNodes = useMemo(() => {
                    if (!searchTerm) return Object.keys(nodeData);
                    return Object.keys(nodeData).filter(nodeName =>
                        nodeName.toLowerCase().includes(searchTerm.toLowerCase())
                    );
                }, [searchTerm]);
            
                // Handle search input changes
                const handleSearchChange = (event) => {
                    setSearchTerm(event.target.value);
                    setSelectedNode(null); // Clear selected node when searching
                };
            
                // Handle a node button click to show details
                const handleNodeClick = (nodeName) => {
                    setSelectedNode(nodeName);
                };
            
                return e("div", { className: "bg-gray-800 min-h-screen text-gray-100 p-8 font-sans" },
                    e("div", { className: "max-w-4xl mx-auto" },
                        e("h1", { className: "text-3xl md:text-4xl font-extrabold text-center mb-6 text-yellow-300" }, "Blender 4.5 LTS Geometry Node 정보 탐색기"),
                        e("p", { className: "text-center text-sm md:text-base text-gray-400 mb-8" }, "노드 이름을 검색하고 클릭하여 입출력 값과 연결 가능한 노드를 확인하세요."),
                        e("div", { className: "flex justify-center mb-8" },
                            e("input", {
                                type: "text",
                                value: searchTerm,
                                onChange: handleSearchChange,
                                placeholder: "노드 이름 검색...",
                                className: "w-full max-w-lg px-4 py-2 rounded-lg bg-gray-900 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-yellow-500 text-gray-200 placeholder-gray-500 transition-all duration-300"
                            })
                        ),
                        e("div", { className: "bg-gray-900 p-6 rounded-2xl shadow-lg" },
                            selectedNode ? (
                                e(NodeDetail, {
                                    nodeName: selectedNode,
                                    data: nodeData[selectedNode],
                                    onNodeClick: handleNodeClick
                                })
                            ) : (
                                e("div", { className: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4" },
                                    filteredNodes.map(nodeName => (
                                        e("div", {
                                            key: nodeName,
                                            onClick: () => handleNodeClick(nodeName),
                                            className: "p-4 bg-gray-700 rounded-lg text-center cursor-pointer hover:bg-yellow-500 hover:text-gray-900 transition-colors duration-200 shadow-md"
                                        }, e("h3", { className: "font-semibold text-lg" }, nodeName))
                                    ))
                                )
                            )
                        )
                    )
                );
            };

            // Render the app
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(e(App));
            // Show the app after rendering
            document.getElementById('root').style.display = 'block';
        };
    </script>
</body>
</html>
