<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>블렌더 4.5 LTS Geometry Node 탐색기</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
        }
        /* Hide the React root element before the app is rendered to prevent a flash of unstyled content */
        #root { display: none; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 antialiased">
    <div id="root"></div>

    <!-- React, ReactDOM, and Babel CDNs -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Framer Motion 라이브러리 링크를 안정적인 CDN으로 수정했습니다. -->
    <script src="https://unpkg.com/framer-motion@11.2.10/dist/framer-motion.umd.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        // This function renders the entire application once all dependencies are ready.
        function renderApp() {
            const { useState, useMemo } = React;
            
            // Get the Framer Motion library object from the window.
            const { motion, AnimatePresence } = window.FramerMotion;

            // Updated data for Blender 4.5 LTS Geometry Nodes.
            const nodeData = {
                "Group Input": {
                    inputs: [],
                    outputs: [{ type: "Geometry", description: "입력된 지오메트리" }],
                    connectsTo: ["Group Output", "Join Geometry", "Set Position", "Extrude Mesh", "Subdivision Surface"]
                },
                "Group Output": {
                    inputs: [{ type: "Geometry", description: "출력할 최종 지오메트리" }],
                    outputs: [],
                    connectsTo: ["Group Input"]
                },
                "Join Geometry": {
                    inputs: [{ type: "Geometry", description: "합칠 지오메트리들" }],
                    outputs: [{ type: "Geometry", description: "하나로 합쳐진 지오메트리" }],
                    connectsTo: ["Set Position", "Extrude Mesh", "Group Output", "Subdivision Surface"]
                },
                "Set Position": {
                    inputs: [
                        { type: "Geometry", description: "위치를 변경할 지오메트리" },
                        { type: "Vector", description: "새로운 위치" },
                        { type: "Vector", description: "위치 오프셋 값" }
                    ],
                    outputs: [{ type: "Geometry", description: "위치가 변경된 지오메트리" }],
                    connectsTo: ["Join Geometry", "Extrude Mesh", "Group Output", "Subdivision Surface"]
                },
                "Extrude Mesh": {
                    inputs: [
                        { type: "Mesh", description: "압출할 메쉬" },
                        { type: "Vector", description: "압출 방향" },
                        { type: "Float", description: "압출 거리" }
                    ],
                    outputs: [{ type: "Mesh", description: "압출된 메쉬" }],
                    connectsTo: ["Join Geometry", "Group Output", "Set Position", "Subdivision Surface"]
                },
                "Transform": {
                    inputs: [
                        { type: "Geometry", description: "변환할 지오메트리" },
                        { type: "Vector", description: "이동 값" },
                        { type: "Vector", description: "회전 값" },
                        { type: "Vector", description: "스케일 값" }
                    ],
                    outputs: [{ type: "Geometry", description: "변환된 지오메트리" }],
                    connectsTo: ["Join Geometry", "Group Output"]
                },
                "Instance on Points": {
                    inputs: [
                        { type: "Geometry", description: "인스턴스를 배치할 점" },
                        { type: "Geometry", description: "인스턴스 할 지오메트리" },
                        { type: "Vector", description: "회전 값" },
                        { type: "Vector", description: "스케일 값" }
                    ],
                    outputs: [{ type: "Geometry", description: "인스턴스가 배치된 지오메트리" }],
                    connectsTo: ["Join Geometry", "Group Output"]
                },
                "Distribute Points on Faces": {
                    inputs: [
                        { type: "Mesh", description: "점을 생성할 메쉬" },
                        { type: "Float", description: "점 밀도" }
                    ],
                    outputs: [
                        { type: "Points", description: "생성된 점" },
                        { type: "Float", description: "선택 출력" }
                    ],
                    connectsTo: ["Instance on Points", "Set Position"]
                },
                "Curve to Mesh": {
                    inputs: [
                        { type: "Curve", description: "변환할 커브" },
                        { type: "Mesh", description: "프로파일 메쉬" }
                    ],
                    outputs: [{ type: "Mesh", description: "변환된 메쉬" }],
                    connectsTo: ["Extrude Mesh", "Join Geometry"]
                },
                "Resample Curve": {
                    inputs: [
                        { type: "Curve", description: "재샘플링할 커브" },
                        { type: "Float", description: "길이" },
                        { type: "Integer", description: "점 개수" }
                    ],
                    outputs: [{ type: "Curve", description: "재샘플링된 커브" }],
                    connectsTo: ["Curve to Mesh", "Set Position"]
                },
                "Subdivision Surface": {
                    inputs: [
                        { type: "Geometry", description: "세분화할 지오메트리" },
                        { type: "Integer", description: "세분화 레벨" }
                    ],
                    outputs: [{ type: "Geometry", description: "세분화된 지오메트리" }],
                    connectsTo: ["Group Output", "Extrude Mesh", "Set Position", "Join Geometry"]
                },
                "Merge by Distance": {
                    inputs: [
                        { type: "Geometry", description: "병합할 지오메트리" },
                        { type: "Float", description: "병합 거리" }
                    ],
                    outputs: [{ type: "Geometry", description: "버텍스가 병합된 지오메트리" }],
                    connectsTo: ["Group Output", "Subdivision Surface"]
                },
                "Delete Geometry": {
                    inputs: [
                        { type: "Geometry", description: "삭제할 지오메트리" },
                        { type: "Boolean", description: "선택" }
                    ],
                    outputs: [{ type: "Geometry", description: "지오메트리가 삭제된 결과" }],
                    connectsTo: ["Group Output", "Extrude Mesh"]
                }
            };
            
            const formatValueType = (type) => {
                switch (type) {
                    case "Geometry": return { color: "bg-gray-400", label: "지오메트리" };
                    case "Mesh": return { color: "bg-blue-400", label: "메쉬" };
                    case "Vector": return { color: "bg-purple-400", label: "벡터" };
                    case "Float": return { color: "bg-green-400", label: "플로트" };
                    case "Integer": return { color: "bg-red-400", label: "정수" };
                    case "Points": return { color: "bg-yellow-400", label: "점" };
                    case "Curve": return { color: "bg-orange-400", label: "커브" };
                    case "Boolean": return { color: "bg-pink-400", label: "불리언" };
                    default: return { color: "bg-gray-400", label: type };
                }
            };

            // Main application component
            const App = () => {
                const [searchTerm, setSearchTerm] = useState('');
                const [selectedNode, setSelectedNode] = useState(null);
            
                const filteredNodes = useMemo(() => {
                    if (!searchTerm) return Object.keys(nodeData);
                    return Object.keys(nodeData).filter(nodeName =>
                        nodeName.toLowerCase().includes(searchTerm.toLowerCase())
                    );
                }, [searchTerm]);
            
                const handleSearchChange = (event) => {
                    setSearchTerm(event.target.value);
                    setSelectedNode(null);
                };
            
                const handleNodeClick = (nodeName) => {
                    setSelectedNode(nodeName);
                };
            
                return (
                    // 메인 컨테이너의 배경색을 body와 다른 bg-gray-800으로 변경하여 렌더링을 시각적으로 확인
                    <div className="bg-gray-800 min-h-screen text-gray-100 p-8 font-sans">
                        <div className="max-w-4xl mx-auto">
                            <h1 className="text-3xl md:text-4xl font-extrabold text-center mb-6 text-yellow-300">
                                Blender 4.5 LTS Geometry Node 정보 탐색기
                            </h1>
                            <p className="text-center text-sm md:text-base text-gray-400 mb-8">
                                노드 이름을 검색하고 클릭하여 입출력 값과 연결 가능한 노드를 확인하세요.
                            </p>
            
                            <div className="flex justify-center mb-8">
                                <input
                                    type="text"
                                    value={searchTerm}
                                    onChange={handleSearchChange}
                                    placeholder="노드 이름 검색..."
                                    className="w-full max-w-lg px-4 py-2 rounded-lg bg-gray-900 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-yellow-500 text-gray-200 placeholder-gray-500 transition-all duration-300"
                                />
                            </div>
            
                            <div className="bg-gray-900 p-6 rounded-2xl shadow-lg">
                                {selectedNode ? (
                                    <NodeDetail
                                        nodeName={selectedNode}
                                        data={nodeData[selectedNode]}
                                        onNodeClick={handleNodeClick}
                                    />
                                ) : (
                                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
                                        <AnimatePresence>
                                            {filteredNodes.map(nodeName => (
                                                <motion.div
                                                    key={nodeName}
                                                    onClick={() => handleNodeClick(nodeName)}
                                                    className="p-4 bg-gray-700 rounded-lg text-center cursor-pointer hover:bg-yellow-500 hover:text-gray-900 transition-colors duration-200 shadow-md"
                                                    initial={{ opacity: 0, scale: 0.9 }}
                                                    animate={{ opacity: 1, scale: 1 }}
                                                    exit={{ opacity: 0, scale: 0.9 }}
                                                    layout
                                                >
                                                    <h3 className="font-semibold text-lg">{nodeName}</h3>
                                                </motion.div>
                                            ))}
                                        </AnimatePresence>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                );
            };

            const NodeDetail = ({ nodeName, data, onNodeClick }) => {
                const [llmResponse, setLlmResponse] = useState(null);
                const [isLoading, setIsLoading] = useState(false);
                
                // Function to call the Gemini API
                const getLlmExplanation = async () => {
                    setIsLoading(true);
                    setLlmResponse(null);
                    
                    try {
                        const prompt = `블렌더 지오메트리 노드인 "${nodeName}"에 대해 상세하게 설명해줘. 이 노드가 어떤 역할을 하고, 어떤 상황에 주로 사용되는지, 그리고 초보자도 이해하기 쉽게 비유를 들어서 설명해줘.`;
                        const apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=';

                        const payload = {
                            contents: [{ parts: [{ text: prompt }] }],
                            tools: [{ "google_search": {} }],
                            systemInstruction: { parts: [{ text: "You are a helpful assistant specialized in explaining Blender Geometry Nodes. Your explanations are clear, concise, and easy for beginners to understand." }] }
                        };

                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        
                        const result = await response.json();
                        const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (text) {
                            setLlmResponse(text);
                        } else {
                            setLlmResponse("정보를 가져오는 데 실패했습니다. 다시 시도해 주세요.");
                        }

                    } catch (error) {
                        console.error('API call failed:', error);
                        setLlmResponse("API 호출 중 오류가 발생했습니다. 잠시 후 다시 시도해 주세요.");
                    } finally {
                        setIsLoading(false);
                    }
                };

                return (
                    <motion.div
                        className="p-6 border-2 border-yellow-500 rounded-lg bg-gray-900"
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: 20 }}
                    >
                        <h2 className="text-3xl font-bold mb-4 text-yellow-300">{nodeName}</h2>
                        
                        {/* Input section */}
                        <div className="mb-6">
                            <h3 className="text-xl font-semibold mb-2">입력 값</h3>
                            {data.inputs.length > 0 ? (
                                <ul className="space-y-2">
                                    {data.inputs.map((input, index) => {
                                        const { color, label } = formatValueType(input.type);
                                        return (
                                            <li key={index} className="flex items-center space-x-3">
                                                <span className={`w-3 h-3 rounded-full ${color}`}></span>
                                                <span className="text-gray-300 font-medium">{label}:</span>
                                                <span className="text-gray-400">{input.description}</span>
                                            </li>
                                        );
                                    })}
                                </ul>
                            ) : (
                                <p className="text-gray-500 italic">이 노드는 입력 값이 없습니다.</p>
                            )}
                        </div>
                        
                        {/* Output section */}
                        <div className="mb-6">
                            <h3 className="text-xl font-semibold mb-2">출력 값</h3>
                            {data.outputs.length > 0 ? (
                                <ul className="space-y-2">
                                    {data.outputs.map((output, index) => {
                                        const { color, label } = formatValueType(output.type);
                                        return (
                                            <li key={index} className="flex items-center space-x-3">
                                                <span className={`w-3 h-3 rounded-full ${color}`}></span>
                                                <span className="text-gray-300 font-medium">{label}:</span>
                                                <span className="text-gray-400">{output.description}</span>
                                            </li>
                                        );
                                    })}
                                </ul>
                            ) : (
                                <p className="text-gray-500 italic">이 노드는 출력 값이 없습니다.</p>
                            )}
                        </div>
                        
                        {/* Connectable nodes section */}
                        <div className="mb-6">
                            <h3 className="text-xl font-semibold mb-2">연결 가능한 다음 노드</h3>
                            {data.connectsTo.length > 0 ? (
                                <div className="flex flex-wrap gap-2">
                                    {data.connectsTo.map((node, index) => (
                                        <motion.button
                                            key={index}
                                            onClick={() => onNodeClick(node)}
                                            className="px-4 py-2 rounded-lg bg-gray-700 text-yellow-300 font-medium hover:bg-yellow-500 hover:text-gray-900 transition-colors duration-200 shadow-md"
                                            whileHover={{ scale: 1.05 }}
                                            whileTap={{ scale: 0.95 }}
                                        >
                                            {node}
                                        </motion.button>
                                    ))}
                                </div>
                            ) : (
                                <p className="text-gray-500 italic">이 노드는 다음 노드로 연결되지 않습니다.</p>
                            )}
                        </div>

                        {/* Gemini API button and response */}
                        <div className="mt-8">
                            <motion.button
                                onClick={getLlmExplanation}
                                className="w-full py-3 rounded-lg bg-yellow-500 text-gray-900 font-bold text-lg hover:bg-yellow-400 transition-colors duration-200 shadow-md"
                                whileHover={{ scale: 1.02 }}
                                whileTap={{ scale: 0.98 }}
                                disabled={isLoading}
                            >
                                {isLoading ? "로딩 중..." : "자세히 보기 ✨"}
                            </motion.button>
                            {llmResponse && (
                                <motion.div
                                    className="mt-6 p-4 bg-gray-700 rounded-lg whitespace-pre-wrap"
                                    initial={{ opacity: 0, y: 20 }}
                                    animate={{ opacity: 1, y: 0 }}
                                >
                                    <h4 className="text-lg font-semibold mb-2">자세한 설명:</h4>
                                    <p>{llmResponse}</p>
                                </motion.div>
                            )}
                        </div>
                    </motion.div>
                );
            };
            
            // Render the app
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(React.createElement(App));
            // Show the app after rendering
            document.getElementById('root').style.display = 'block';
        }

        // Check if Framer Motion library is loaded.
        function checkForFramerMotion() {
            if (window.FramerMotion) {
                // If loaded, render the app.
                renderApp();
            } else {
                // If not yet loaded, try again after 50ms.
                setTimeout(checkForFramerMotion, 50);    
            }
        }
        
        window.onload = function() {
            // Check for Framer Motion after all files have loaded.
            checkForFramerMotion();
        };
    </script>
</body>
</html>
